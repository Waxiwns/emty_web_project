1. https://javarush.ru/groups/posts/305-sozdanie-prosteyshego-web-proekta-v-intellij-idea-enterprise-edition-poshagovo-s-kartinkami
2. https://javarush.ru/groups/posts/328-sozdanie-prostogo-veb-prilozhenija-na-servletakh-i-jsp-chastjh-1

Создание простейшего веб-проекта в IntelliJ Idea Enterprise. Пошагово, с картинками

Уровень знаний, необходимых для понимания статьи: вы уже более-менее разобрались с Java Core и хотели бы посмотреть на JavaEE-технологии и web-программирование. Логичнее всего, если вы сейчас изучаете квест Java Collections, где рассматриваются близкие статье темы.    



В настоящее время я использую IntelliJ IDEA Enterprise Edition (это платная расширенная версия IDE, её обычно используют в профессиональной разработке, — прим. ред.). В ней гораздо проще работать с веб-проектами, чем в бесплатной Community Edition. Так, в Enterprise Edition буквально по одному щелчку мышки происходит сборка проекта, заливается в контейнер сервлетов, запускается сервер и даже открывается страничка с запущенным проектом в браузере. В бесплатной версии идеи многое из этого пришлось бы делать самостоятельно, так сказать, «ручками». 

Для сборки проекта и управления его жизненным циклом я пользуюсь Apache Maven. В этом я использовал лишь малую толику его возможностей (управление пакетами/зависимостями).

В качестве контейнера сервлетов/сервера приложений (Application server) я выбрал Apache Tomcat версии 9.0.0.М4. Я знаю, что уже есть и более новые версии, но у меня установлена именно эта.

Приступаем


Для начала откроем IntelliJ IDEA и создадим пустой Maven-проект.



Тут слева выбираем Maven, проверяем, чтобы сверху была указана JDK для проекта. Если её нет, выберите необходимую из списка, либо жмите New… и выбирайте напрямую с компьютера.

В середине окна у меня крутится анимация загрузки списка архетипов. Нам они не нужны, поэтому, не дожидаясь загрузки, смело клацаете Next внизу окна.



В этом окне необходимо указать GroupId и ArtifactId.

Под GroupId подразумевается уникальный идентификатор компании, которая выпускает проект. Обычно принято использовать доменное имя компании, только в обратном порядке. Не в смысле, зеркально, а если, например, доменное имя компании maven.apache.org, то ее GroupId будет org.apache.maven. То есть сначала пишем домен первого уровня, отделяем точкой, пишем имя домена второго уровня, и так далее. Это общепринятый подход. 

В том случае, если вы «пилите» проект самостоятельно, а не в составе компании, пишите сюда ваше личное доменное имя (тоже в обратном порядке!). Если оно у вас, конечно же, есть:). Если нет — не расстраивайтесь. В действительности сюда можно написать что угодно.

Для компании с доменным именем vasya.pupkin.org, GroupId будет org.pupkin.vasya. Такой подход к именам нужен для того, чтобы отделять проекты с одинаковым названием, но которые выпустили разные компании.


В этом примере я буду использовать вымышленное доменное имя fatfaggy.info.javarush.ru. Соответственно, в поле GroupId я вписываю ru.javarush.info.fatfaggy. 

ArtefactId — это просто название нашего проекта. Можно использовать буквы и некоторые знаки (дефис, например) для разделения слов. Наш «артефакт» будет называться именно так, как мы тут напишем. В этом примере, я пишу my-super-project. 

Поле версии пока не трогаем, оставляем как есть.



Ну и стандартное окошко IDEA при создании нового проекта. Назовем его по традиции my-super-project. 



Проект создан! 

Перед нами сразу открылся файл pom.xml. Это файл, с настройками Maven. Если мы хотим «рассказать» Maven’у, что и как делать или откуда что-то брать, мы описываем всё это в этом самом файле pom.xml. Он находится в корне проекта.

Видим, что в нём указаны сейчас именно те данные, которые мы вводили при создании Maven-прокта: groupId, artifactId и version (последний мы не трогали).

Структура нашего проекта

 
Этот Maven-проект имеет определенную структуру. 



Как видим, в корне лежат:
директория .idea, в которой находятся настройки идеи для текущего проекта;
директория src, в которой мы создаем наши исходники;
файл my-super-project.iml, файл проекта, созданный IDEA;
файл pom.xml, тот самый файл Maven-проекта, о котором я говорил чуть выше, который у нас сейчас открыт. Если я буду где-то упоминать pom.xml или «помник», я буду иметь в виду именно этот файл.


В папке src в свою очередь лежат две подпапки:
main — для нашего кода;
test — для тестов для нашего кода.

И в main, и в test есть папка java. Считайте, что это одна и та же папка, только та, что в main —для кода исходников, а та, что в test — для кода тестов соответственно.

Папка resources нам пока вообще не нужна, мы не будем ее использовать. Но пусть полежит. 

Превращение в веб-проект


Пришло время наш преобразовать наш Maven-проект в веб-проект. Для этого кликаем правой кнопкой мышки по названию проекта в этом дереве и выбираем пункт Add framework support…



Откроется окно, где мы можем добавить поддержку всяких разных фреймворков для нашего проекта. Но нам нужен только один: Web Application. Его и выбираем.



Проверяем, что стоит галочка напротив Web Application, а в основной части окна отмечено, что мы хотим, чтобы для нас создали сразу ещё и файл web.xml (рекомендую поставить галочку, если её там нет).

После этого мы увидим, что структура нашего проекта пополнилась папочкой web.



Это корень нашего веб-проекта с адресом /. То есть, если мы введем в браузере адрес localhost (когда запустим, конечно же), то это будет обращение именно сюда, в корень веб-проекта. Если введем localhost/addUser, то в папочке web будет искаться ресурс с названием addUser.

Главное, надо понять, что папка web — корень нашего проекта, когда мы его зальем на Tomcat. Сейчас у нас есть определённая структура папок, но в готовом проекте, который мы будем заливать, она будет немного другой, и именно папочка web там будет корнем.

В web лежит обязательная папка с названием WEB-INF, где находится файл web.xml, который мы просили создать на прошлом шаге. Откроем его.



Как видим, в нем пока нет ничего интересного, одна только «шапка». Кстати, если бы мы не просили его создавать, нам бы, возможно, пришлось создавать его вручную, то есть набирать «ручками» всю эту «шапку», или, в крайнем случае искать готовый вариант в интернетах.

Для чего нужен web.xml? Для маппинга. Здесь мы распишем для Tomcat, какие url-запросы передавать на какие сервлеты. Но это все позже, пока оставляем его пустым.

Ещё в папочке web есть файл index.jsp. Откроем его.



Это файл, который будет выполнен по умолчанию, так сказать. То есть когда мы запустим проект, то именно его и узреем. По сути, jsp — обычный html-файл, с той разницей, что в нём можно выполнять java-код.

Немного про статический и динамический контент


Статический контент — такой, который не меняется со временем. Всё то, что мы написали в html файле написали — то и будет отображаться без изменений. Если мы написали hello world — то эта надпись отобразится и как только мы откроем страничку, и через 5 минут, и завтра, и через неделю, и через год. Она не изменится.

Но что, если мы хотим на страничке вывести текущую дату? Если мы просто напишем «27 октября 2017 года» — то и завтра мы увидим такую же дату, и через неделю, и через год. А хотелось бы, чтобы эта дата была все-таки актуальна. Именно тут нам и приходит на помощь возможность выполнять какой-то код прямо внутри страницы. Мы можем получить объект даты, привести его к нужному нам виду и вывести на странице. Тогда каждый день когда бы мы не открыли страничку — дата будет всегда актуальна.

Если нам нужен только статический контент — то нам достаточно обычного веб-сервера и html файлов. Никакой джавы, мавенов, томкатов нам и не нужно.

Но если мы хотим использовать динамический контент — вот тут то нам все это и пригодится.

Но пока вернемся к нашему index.jsp.

Давайте укажем вместо стандартного заголовка что-то свое, например «My super web-app!», а в теле напишем например «I'm alive!».

Мы уже почти готовы к тому, чтобы запустить наш проект!

Но, к сожалению, привычный зеленый треугольничек для запуска программы у нас не активен.



Нажмем на кнопку слева от него (указал на скрине красной стрелочкой) и выберем Edit configurations…

Откроется окно, где нам предлагают нажать на зеленый плюсик чтоб добавить какую-то конфигурацию. Нажмем на него, он находится в левом верхнем углу окна.



Выберем пункт Tomcat Server и подпункт Local.

Откроется окно со множеством всяческих параметров, но нас почти все устраивает и дефолтное.



Можем как-нибудь красиво назвать нашу конфигурацию вместо стандартного Unnamed (в самом верху).

Так же необходимо проверить, что идея успешно нашла томкат у нас в системе (вы же его перед этим уже скачали и установили, да?). Если не нашла (что вряд ли) — нажимаем стрелочку вниз и выбираем где он у нас установлен, ну или же другую версию, если у вас их несколько. У меня он один и уже установлен, поэтому выглядит все так, как на скрине.

И в самом низу окна видим, что светится предупреждение, что пока нет ни одного артефакта, предназначенного для деплоя на сервер. А справа от этой надписи кнопочка, которая предлагает этот недочет исправить.

Жмем на нее и видим, что идея сама все нашла, сама все создала, чего ей не хватало, и сама все настройки проставила.



Видим, что нас со вкладки Server перебросило на вкладку Deployment, в разделе Deploy at the server startup у нас уже указан артефакт, который надо деплоить, ну а внизу указано, что перед деплоем этот артефакт будет билдиться.

Apply, Ok.

И видим, что во первых, внизу окна появился раздел с нашим локальным сервером томкат, в который будет помещен наш артефакт. Свернуть этот раздел можно нажав на соответствующею кнопку в правой части окна.



Так же видим, что зеленый треугольничек для запуска уже активен.

Для тех, кто хочет все проверить — можно нажать на кнопку с настройками проекта (справа от кнопок запуска, помечена красной стрелкой), перейти в раздел Artifacts и убедиться, что артефакт действительно создан. Его не было до того момента, пока мы не нажали ту кнопку Fix, но теперь все ок. И такая конфигурация нас вполне устраивает.

Если в двух словах чем отличается my-super-project:war от my-super-project:war exploded — так это тем, что my-super-project:war создаст только один файл war (который является просто архивом), а вариант с exploded — это просто «распакованный» war. И именно такой вариант лично мне более удобен, так как позволяет быстрее деплоить мелкие изменения на сервер.

По сути, артефакт — это и есть наш проект, только уже скомпилированный, и в котором изменена структура папок так, чтобы его можно было выкладывать уже напрямую на томкат.

Выглядеть она будет примерно вот так:



Ну что ж, теперь все готово для запуска нашего проекта.

Жмем заветную зеленую кнопочку запуска и наслаждаемся результатом! :)





Создание простого веб-приложения на сервлетах и jsp (часть 1)

Уровень знаний, необходимых для понимания статьи: вы уже более-менее разобрались с Java Core и хотели бы посмотреть на JavaEE-технологии и web-программирование. Логичнее всего, если вы сейчас изучаете квест Java Collections, где рассматриваются близкие статье темы.   



Этот материал является логическим продолжением моей статьи Создание простейшего веб-проекта в IntelliJ Idea Enterprise. В ней я продемонстрировал, как создать работающий шаблон веб-проекта.

В этот раз я покажу, как создать простое, но вполне симпатичное веб-приложение с помощью технологий Java Servlet API и JavaServer Pages API.

У нашего приложения будет главная страница с двумя ссылками:

на страницу добавления пользователя;
на страницу просмотра списка пользователей.


Я по-прежнему буду использовать IntelliJ Idea Enterprise Edition, Apache Maven (просто подключим несколько зависимостей) и Apache Tomcat. В конце «украсим» наше приложение используя фреймворк W3.CSS.  

Будем считать, что на данный момент у вас уже есть пустой проект, который мы и будем тут развивать. Если же нету — пробегитесь по первой статье и сделайте его. Это займет всего лишь несколько минут :)

Немного о структуре будущего приложения
Главная страница (/) у нас будет самой обычной статической html-страничкой с шапкой и двумя ссылками/кнопками:

добавить нового пользователя (будет отправлять на адрес /add);
просмотреть список пользователей (отправляет на адрес /list).

Запросы по этим адресам Tomcat будет ловить и отправлять на один из двух сервлетов, которые мы сделаем (маппинг мы распишем в файле web.xml). А сервлеты, в свою очередь, будут обрабатывать запросы, подготавливать данные (или сохранять их в случае добавления пользователя), и передавать управление в соответствующие jsp-файлы, которые уже будут «отрисовывть» результат.

Данные будем хранить в самом обычном списке (List).

Создадим статическую главную страницу
Если у вас в папке web лежит index.jsp — удаляйте его. Вместо него в этой папке создадим простой html-файл с именем index.html:

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>My super project!</title>
</head>
<body>
    <!-- header -->
    <div>
        <h1>Super app!<//h1>
    </div>

    <div>       <!-- content -->
        <div>    <!-- buttons holder -->
            <button onclick="location.href='/list'">List users<//button>
            <button onclick="location.href='/add'">Add user<//button>
        </div>
    </div>
</body>
</html>

Тут ничего сложного. В title указываем заголовок нашей страницы. В теле страницы у нас два основных дива: header (шапка) и content (контент). В контенте у нас холдер для наших кнопок, ну и собственно две кнопки, которые по нажатию отправляют на соответствующие адреса.

Можете запустить проект, и посмотреть, как он сейчас выглядит. Если нажимать на кнопки, открываются страницы с ошибкой 404, потому что у нас их пока нет. Но это говорит о том, что кнопки работают.

Замечу, это не самый универсальный вариант, поскольку если у вас вдруг отключён JavaScript, в браузере от этих кнопок толку никакого. Но будем считать, что никто JavaScript не отключал:). Ясно, что можно было бы обойтись простыми ссылками, но мне больше по душе кнопочки. Вы же делайте, как вам больше нравится. И не смотрите, что в моих примерах будет много div-ов. Потом мы их наполним стилями, и всё станет выглядеть красивее:). 

Создаем jsp-файлы для отрисовки результата
В той же директории web создадим папку, куда будем складывать наши jsp-файлы. Я назвал её views, а вы, снова-таки, можете поимпровизировать.

В этой папке создадим два jsp-файла:

add.jsp — страничка для добавления пользователей;
list.jsp — страничка для показа списка пользователей.

Проставим им соответствующие заголовки страницы. Что-нибудь вроде «Add new user» и «Users list», и пока так и оставим.

Создадим два сервлета
Сервлеты будут принимать и обрабатывать запросы, которые им будет передавать Tomcat. В папке src/main/java создадим пакет app, в котором будут лежать наши исходники. Там у нас будет ещё разных пакета. Поэтому, чтобы эти пакеты не создавались внутри друг друга, давайте создадим в пакете app какой-нибудь класс (потом удалим). Теперь создадим в пакете app три разных пакета:

entities — тут будут лежать наши сущности (сам класс, который будет описывать объекты пользователей);
model — тут будет наша модель (об этом чуть позже);
servlets — ну а тут будут наши сервлеты.

После этого тот класс из пакета app можно спокойно удалять (если вы его, конечно, создавали).

В пакете servlets создадим два класса:

AddServlet — будет обрабатывать запросы, поступившие по адресу /add;
ListServlet — будет обрабатывать запросы, поступившие по адресу /list.

Подключение зависимостей в Maven
Tomcat версии 9.* реализует спецификации Servlet версии 4.0 и JavaServer Pages версии 2.3. Об этом написано в официальной документации 9-го Tomcat в первом же абзаце во второй строке.

Это значит, что если вы, как и я, используете эту версию Tomcat, то наш код, который мы напишем и отправим выполняться, будет использовать именно указанные версии. Но нам бы хотелось иметь эти спецификации и в нашем проекте, чтобы наш код, который их использует, хотя бы успешно компилировался. А для этого нам надо их подгрузить к себе в проект. Вот тут-то и приходит на помощь Maven.

Общее правило следующее: если вам надо подключить что-то к вашему проекту, используя Maven:

идете на сайт репозитория от Maven;
ищите там нужную вам библиотеку нужной версии;
получаете код зависимости, который надо вставить в ваш pom.xml;
вставляете! :)


Итак, начинаем. Для начала, подготовим pom-файл. Где-то после записи /version, но до /project вставляете следующее:

<dependencies>

</dependencies>

Тем самым мы указали, что внутри этих тегов мы перечислим нужные нам зависимости.

Теперь заходите на mvnrepository.com, там вверху будет поле поиска. Для начала вбиваете в поиск servlet. Первый же результат, где более семи тысяч использований, нам и подходит. Помним, что нам нужна версия 4.0 (для 9-го Tomcat, для других версий, возможно, подойдут и более старые реализации). Это довольно свежая версия, поэтому использований не так уж и много, но нам нужна именно она. Откроется страница, откуда можно взять код этой зависимости для разнообразных менеджеров пакетов и даже можно просто скачать. Но поскольку мы хотим подключить её с помощью Maven, то и код выбираем на вкладке Maven. Копируем и вставляем в наш pom-файл внутрь раздела с зависимостями.

Если в правом нижнем углу IDEA вылезет уведомление, где спросят, хотим ли мы включить автоимпорт, соглашаемся. Если случайно отказались, заходите в «Настройки» и включите автоимпорт вручную: Settings (Ctrl + Alt + S) -> Build, Execution, Deployment -> Maven -> Importing

Это позволит держать pom-файл и файлы настройки IDEA для этого проекта синхронизированными.

Теперь по тому же принципу найдем и подключим JavaServer Pages версии 2.3 (в поиске вбиваете jsp).

И раз мы уже взялись за Maven, давайте сразу укажем ему, что наши исходники соответствуют синтаксису Java 8, и что компилировать их нужно в байткод той же версии.

После всех этих манипуляций наш pom.xml будет выглядеть примерно так:

<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>ru.javarush.info.fatfaggy</groupId>
    <artifactId>my-super-project</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compile.source>1.8</maven.compile.source>
        <maven.compile.target>1.8</maven.compile.target>
    </properties>

    <dependencies>
        <!-- Servlet API 4.0 for tomcat 9 -->
        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>javax.servlet-api</artifactId>
            <version>4.0.0</version>
            <scope>provided</scope>
        </dependency>

        <!-- JavaServer Pages API 2.3 for tomcat 9 -->
        <dependency>
            <groupId>javax.servlet.jsp</groupId>
            <artifactId>javax.servlet.jsp-api</artifactId>
            <version>2.3.1</version>
            <scope>provided</scope>
        </dependency>
    </dependencies>

</project>

Делаем из наших сервлетов настоящие сервлеты
В данный момент пара созданных нами сервлетов на деле являются обычными классами. У них нет никакой функциональности. Но теперь-то мы подключили к нашему проекту Servlet API, а, раз так, мы можем использовать классы оттуда.

Чтоб сделать наши сервлеты «настоящими» сервлетами, достаточно просто унаследовать их от класса HttpServlet.

Маппинг или разметка

Теперь было бы неплохо как-то рассказать Tomcat, чтобы запросы с адреса /add обрабатывались нашим сервлетом AddServlet, и, соответственно, запросы по адресу /list обрабатывались сервлетом ListServlet. Именно этот процесс и называется маппингом(разметкой).

Делается это в файле web.xml по такому принципу: 

сначала описываем сервлет (даем какое-то имя и указываем путь к самому классу);
потом привязываем этот сервлет к конкретному адресу (указываем имя сервлета, которое мы ему только-что дали и указываем адрес, запросы с которого стоит отправлять на этот сервлет).

Описываем сервлет:

<servlet>
    <servlet-name>add</servlet-name>
    <servlet-class>app.servlets.AddServlet</servlet-class>
</servlet>

Теперь привязываем его к адресу:

<servlet-mapping>
    <servlet-name>add</servlet-name>
    <url-pattern>/add</url-pattern>
</servlet-mapping>



Как видно, servlet-name в обоих случаях одинаковое. Благодаря этому Tomcat знает, что если пришел запрос на адрес /add, его нужно передать в сервлет app.servlets.AddServlet.

Со вторым сервлетом проделываем то же самое. В итоге, наш web.xml имеет примерно следующее содержание: 

<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"
         version="3.1">

    <!-- add servlet -->
    <servlet>
        <servlet-name>add</servlet-name>
        <servlet-class>app.servlets.AddServlet</servlet-class>
    </servlet>

    <servlet-mapping>
        <servlet-name>add</servlet-name>
        <url-pattern>/add</url-pattern>
    </servlet-mapping>

    <!-- list servlet -->
    <servlet>
        <servlet-name>list</servlet-name>
        <servlet-class>app.servlets.ListServlet</servlet-class>
    </servlet>

    <servlet-mapping>
        <servlet-name>list</servlet-name>
        <url-pattern>/list</url-pattern>
    </servlet-mapping>
</web-app>


Кстати, мы тут не создали разметку для главной страницы (по адресу /). Дело в том, что в данном случае он нам и не нужен. Наша главная страница — простой html-файл, который просто отображает две кнопки. Там нет динамического контента, поэтому нам нет смысла заводить под него отдельный сервлет, на который будут передаваться запросы с адреса /, и который не будет ничего делать, кроме передачи выполнения на какую-нибудь jsp (которую тоже пришлось бы завести), которая и рисовала бы нам две кнопки. Нам этого не нужно, нас устраивает статичный ресурс. Tomcat когда получит запрос, проверит, что нет ни одного сервлета, который смог бы обработать запрос по такому адресу, а потом увидит что по этому адресу собственно лежит уже готовый html-файл, который он успешно и отдаст.

Можем запустить наше приложение снова (перезапустить сервер или задеплоить повторно, как вам больше хочется) и убедиться, что главная страничка отрисовывается, ничего не сломалось, когда нажимаем на кнопки — то переходы происходят, но пока тоже пишется ошибка. Кстати, если до этого у нас была ошибка 404, то теперь 405. Значит маппинг сработал, сервлеты нашлись, да вот только не нашлось в них подходящих методов чтоб обработать запрос.

Краткое лирическое отступление: что происходит «под капотом»?
Вы, наверное, уже успели задуматься, каким образом наше приложение работает в Tomcat? Что там вообще происходит? И где метод main()?

Как только вы вбиваете в браузере localhost:8080 и переходите по этому адресу, браузер отправляет на этот адрес запрос по протоколу http. Надеюсь, вы уже в курсе, что запросы могут быть разных «типов», самый популярные — GET и POST. На каждый запрос должен быть ответ. GET-запрос ожидает, что в ответ ему отдадут готовый html-код, который вернется в браузер, а браузер уже этот код красиво заменит на всякие буковки, кнопочки, формочки. POST-запрос немного интереснее, так как он с собой еще несет некую информацию. Например, в форме регистрации или авторизации пользователя вы ввели свои данные и нажали «отправить». В этот момент на сервер отправился POST-запрос с вашей личной информацией внутри. Сервер эту информацию принял, обработал и вернул какой-нибудь ответ (например, html-страничку с вашим профилем). Принципиальное отличие между ними в том, что GET-запросы предназначены только для получения данных с сервера, а POST-запросы несут с собой какую-то информацию, и данные на сервере могут измениться (например, когда вы заливаете свою фотку на сервер, она полетит в POST-запросе и сервер добавит её в базу данных, то есть произойдет какое-то изменение.

Теперь вернемся к Tomcat. Когда он получает от клиента какой-то запрос, он смотрит на адрес. Ищет по своим данным, есть ли подходящий сервлет, который бы обрабатывал запросы по такому адресу (ну или готовый ресурс, который можно прям сразу и вернуть). Если он не нашел что вернуть, он кидает в ответ не html-страничку, а 404-ответ.

Если же он нашел подходящий сервлет, который «сидит» на этом адресе, он смотрит какой тип запроса он получил (GET, POST, или какой-то другой), а потом спрашивает у сервлета, есть ли у него метод, который умел бы обрабатывать такой тип запросов. Если сервлет говорит, что не умеет обрабатывать такой тип, Tomcat кидает клиенту в ответ код 405. Что и произошло только-что у нас.

Но если же нашелся и подходящий сервлет, и у него есть подходящий метод, Tomcat создает объект этого сервлета, запускает его в новом треде (thread), что позволяет сервлету работать в отдельном потоке, а Tomcat продолжает работать и дальше в своем, принимать и отправлять запросы. 

Кроме того, Tomcat создает ещё два объекта: один типа HttpServletRequest (коротко я его буду называть дальше запросом), а второй — типа HttpServletResponse (буду называть ответом). В первый объект она помещает все данные, что ему пришли в запросе от клиента, таким образом из этого объекта все те данные можно будет вытащить.

Ну и после всего этого передает два эти объекта в подходящий метод того сервлета, который запущен в отдельном потоке. Как только сервлет закончит работу и у него будет готов ответ, который надо отправить клиенту, он поднимает флаг Tomcat’у, мол, «я закончил, все готово». Tomcat принимает ответ и отправляет его клиенту.

Это позволяет Tomcat не отвлекаясь принимать запросы и отправлять ответы, а всю работу делают сервлеты, которые крутятся в отдельных потоках. Соответственно, когда мы пишем код сервлета, мы и определяем ту работу, которая будет выполняться.

И да, можете считать, что метод main() находится в самом Tomcat (да, он написан на Java), и когда мы «запускаем» Tomcat, запускается метод main().

Ловим сервлетами GET-методы и отправляем простейшие ответы
В данный момент, в наших сервлетах нет подходящих методов (GET), поэтому Tomcat нам возвращает ошибку 405. Сделаем их!

В классе HttpServlet, от которого мы унаследовали наши сервлеты, определены разные методы.
Для того, чтобы задать какой-то код для методов, мы их просто переопредеяем. В данном случае нам надо переопределить метод doGet() в обоих сервлетах.


@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

}

Как видим, этот метод принимает два обьекта: req (запрос) и resp (ответ). Это те самые объекты, которые создаст и наполнит нам Tomcat, когда вызовет соответствующий метод в этом сервлете. Для начала давайте сделаем простейшие ответы. Для этого возьмем объект resp и получим из него объект PrintWriter-а, которым можно составлять ответы. Ну и при помощи него выведем какую-нибудь простую строку.

@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    PrintWriter writer = resp.getWriter();
    writer.println("Method GET from AddServlet");
}

Что-то подобное сделаем и в сервлете ListServlet, после чего запустим наш сервер снова. Как видим, все работает! При нажатии на кнопки открываются странички с тем текстом, который мы «записали» PrintWriter-ом.

Вот только те наши jsp, которые мы подготовили для формирования страничек с ответами никак не используются. Это потому, что выполнение до них просто не доходит. Сервелет сам у нас сейчас формирует ответ и заканчивает работу, сигнализируя Tomcat, что у него готов ответ клиенту. Tomcat же просто берет этот ответ и отправляет его назад клиенту.

Передаем управление из сервлетов в jsp

Изменим код наших методов таким образом:

получаем из объекта запроса объект диспетчера запросов, куда передаем адрес jsp странички, которой мы хотим передать управление;
используя полученный объект — передаем управление в указанную jsp страницу, и не забываем вложить туда те объекты запроса и ответа, которые мы получили от Tomcat.

@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    RequestDispatcher requestDispatcher = req.getRequestDispatcher("views/add.jsp");
    requestDispatcher.forward(req, resp);
}

В теле jsp-страниц (внутри тега body) можно что-то написать, чтобы мы могли четко видеть, какая из страниц отображается. После этого перезапускаем сервер и проверяем. Кнопочки на главной странице нажимаются, странички открываются, а, значит, запросы в сервлеты передаются, после чего управление передается в jsp страницы, которые уже и отрисовываются.

На этом всё. В следующей части статьи мы займемся функциональностью нашего приложения. 
